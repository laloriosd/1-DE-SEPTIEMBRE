# -*- coding: utf-8 -*-
"""Dashboard de Documentos Recibidos 6

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1kQp7dFARbAkfAypLPdvMDFp-_SF93EyG
"""

import streamlit as st
import pandas as pd
import plotly.express as px
import plotly.graph_objects as go
from plotly.subplots import make_subplots
import numpy as np
from PIL import Image # Import Pillow to handle images

# Título del dashboard
st.title("Dashboard de Documentos Recibidos")


# Cargar el logo
try:
    # Asegúrate de que la ruta al archivo del logo sea correcta
    logo = Image.open('logobancoSANTANDER.png')
    # Puedes ajustar el tamaño del logo si es necesario
    # logo = logo.resize((100, 100)) # Ejemplo de redimensionamiento
except FileNotFoundError:
    st.error("Error: Asegúrate de que el archivo 'logobancoSANTANDER.png' esté en la misma carpeta que el script de Streamlit.")
    logo = None # Establecer logo a None if file not found
except Exception as e:
    st.error(f"Error al cargar el logo: {e}")
    logo = None


# Mostrar el logo si se cargó correctamente
if logo:
    st.image(logo, width=150) # Ajusta el ancho según sea necesario

# Cargar y procesar datos
try:
    # Asegúrate de que la ruta a los archivos de datos sea correcta en tu entorno de Streamlit
    df_notificaciones = pd.read_excel('Base Notificaciones_Banco_Dummie.xlsx')
    df_coordenadas = pd.read_excel('Latitud y longitud.xlsx')

    # Limpieza y preparación de datos de notificaciones
    df_notificaciones.dropna(inplace=True) # Manejar nulos

    columns_to_clean = ['PLAZA/ENTIDAD', 'ZONA', 'MATERIA', 'TURNADO A']
    for col in columns_to_clean:
        df_notificaciones[col] = df_notificaciones[col].astype(str).str.replace(' ', '', regex=False) # Eliminar espacios y asegurar que sean strings

    columns_to_categorize = ['ZONA', 'MATERIA', 'TURNADO A']
    for col in columns_to_categorize:
        df_notificaciones[col] = df_notificaciones[col].astype('category') # Categorizar columnas

    df_notificaciones.columns = df_notificaciones.columns.str.replace(' ', '_') # Renombrar columnas con guion bajo


    # Preparar datos geográficos y combinar
    df_coordenadas = df_coordenadas.rename(columns={'Ciudad, Estado': 'PLAZA/ENTIDAD'}) # Renombrar columna para fusión

    # Asegurar que la columna de fusión en ambos DFs sea string para evitar problemas
    df_notificaciones['PLAZA/ENTIDAD'] = df_notificaciones['PLAZA/ENTIDAD'].astype(str)
    df_coordenadas['PLAZA/ENTIDAD'] = df_coordenadas['PLAZA/ENTIDAD'].astype(str)

    # Apply the same space removal to the merge key in df_coordenadas
    df_coordenadas['PLAZA/ENTIDAD'] = df_coordenadas['PLAZA/ENTIDAD'].str.replace(' ', '', regex=False)


    # Ensure Latitud and Longitud are strings in df_coordenadas before merge and handle potential NaNs
    df_coordenadas['Latitud'] = df_coordenadas['Latitud'].astype(str).fillna('') # Convert to string and fill NaN with empty string
    df_coordenadas['Longitud'] = df_coordenadas['Longitud'].astype(str).fillna('') # Convert to string and fill NaN with empty string

    df_merged = pd.merge(df_notificaciones, df_coordenadas, on='PLAZA/ENTIDAD', how='left')

    # Convertir latitud y longitud a numérico
    def convert_lat_lon(coord_series):
        # Ensure the series is of string type and handle potential NaNs/None explicitly
        coord_series_str = coord_series.astype(str).fillna('')

        # Only process non-empty string values that match the pattern
        valid_coords = coord_series_str[coord_series_str.str.match(r'([\d.]+)°\s*([NSEOW])')]

        if not valid_coords.empty:
            values = valid_coords.str.extract(r'([\d.]+)°\s*([NSEOW])')
            values.columns = ['Value', 'Direction']
            values['Value'] = pd.to_numeric(values['Value'], errors='coerce')
            values['Value'] = np.where(values['Direction'].isin(['O', 'S']), -values['Value'], values['Value'])
            # Reindex the result to match the original series index
            result = pd.Series(np.nan, index=coord_series.index, dtype=float) # Initialize with NaNs
            result.loc[valid_coords.index] = values['Value'] # Assign converted values to matching indices
            return result
        # Return a series of NaNs if no valid coordinates were found or input was empty/all null/non-matching
        return pd.Series(np.nan, index=coord_series.index)


    df_merged['Latitud'] = convert_lat_lon(df_merged['Latitud'])
    df_merged['Longitud'] = convert_lat_lon(df_merged['Longitud'])


    # Eliminar filas con coordenadas nulas after conversion
    df_merged.dropna(subset=['Latitud', 'Longitud'], inplace=True)

    st.write("DataFrame fusionado después de conversión y dropna (df_merged):", df_merged.head()) # Debug print
    st.write("Shape de df_merged después de conversión y dropna:", df_merged.shape) # Debug print


    # --- Crear Visualizaciones ---

    # Visualización 1: Número de Documentos Recibidos por Zona (Gráfico de Barras)
    zona_counts = df_merged['ZONA'].value_counts().reset_index()
    zona_counts.columns = ['ZONA', 'Count']
    st.write("Data for Zone Bar Chart (zona_counts):", zona_counts) # Debug print

    fig_bar = go.Figure(go.Bar(x=zona_counts['ZONA'], y=zona_counts['Count'],
                               marker=dict(color=zona_counts['Count'], colorscale='Reds')))
    fig_bar.update_layout(title_text="Número de Documentos Recibidos por Zona")


    # Visualización 2: Porcentaje de Documentos con Confirmación 'Sí' (Gauge Chart)
    total_documents = len(df_merged)
    # Asegurarse de que la columna CONFIRMACION esté en el formato correcto (string)
    df_merged['CONFIRMACION'] = df_merged['CONFIRMACION'].astype(str).str.strip()
    sí_confirmations_count = df_merged[df_merged['CONFIRMACION'] == 'Sí'].shape[0]
    st.write("Total Documents:", total_documents) # Debug print
    st.write("Count of 'Sí' Confirmations:", sí_confirmations_count) # Debug print


    sí_percentage = (sí_confirmations_count / total_documents) * 100 if total_documents > 0 else 0
    st.write("Percentage of 'Sí' Confirmations:", sí_percentage) # Debug print


    fig_gauge = go.Figure(go.Indicator(
        mode = "gauge+number",
        value = sí_percentage,
        title = {'text': "Porcentaje de Documentos con Confirmación 'Sí'"},
        gauge = {'axis': {'range': [None, 100]},
                 'bar': {'color': "darkred"},
                 'steps': [
                     {'range': [0, 50], 'color': 'salmon'},
                     {'range': [50, 100], 'color': 'indianred'}]
                }))


    # Visualización 3: Distribución de Documentos por Plaza/Entidad (Mapa Geográfico)
    plaza_counts = df_merged['PLAZA/ENTIDAD'].value_counts().reset_index()
    plaza_counts.columns = ['PLAZA/ENTIDAD', 'Count']
    plaza_counts['Percentage'] = (plaza_counts['Count'] / plaza_counts['Count'].sum()) * 100
    st.write("Data for Plaza/Entity Map (plaza_counts):", plaza_counts) # Debug print


    # Merge with geo data and drop rows with missing lat/lon
    plaza_geo_df = pd.merge(plaza_counts, df_merged[['PLAZA/ENTIDAD', 'Latitud', 'Longitud']].drop_duplicates(), on='PLAZA/ENTIDAD', how='left')
    plaza_geo_df.dropna(subset=['Latitud', 'Longitud'], inplace=True) # Eliminar nulos después de la fusión
    st.write("Data for Geo Map after merge and dropna (plaza_geo_df):", plaza_geo_df) # Debug print
    st.write("Shape of plaza_geo_df after merge and dropna:", plaza_geo_df.shape) # Keep this debug print


    fig_map = go.Figure(go.Scattergeo(
        lat=plaza_geo_df['Latitud'],
        lon=plaza_geo_df['Longitud'],
        mode='markers',
        marker=dict(
            size=plaza_geo_df['Count']/2, # Ajustar tamaño según el conteo
            color=plaza_geo_df['Percentage'],
            colorscale='Reds',
            colorbar=dict(title='Percentage'),
            line_color='black',
            line_width=0.5,
            sizemode='area'
        ),
        text=plaza_geo_df['PLAZA/ENTIDAD'] + '<br>Count: ' + plaza_geo_df['Count'].astype(str) + '<br>Percentage: ' + plaza_geo_df['Percentage'].round(2).astype(str) + '%',
        hoverinfo='text'
    ))

    fig_map.update_layout(
        title_text="Distribución de Documentos por Plaza/Entidad",
        geo=dict(
            scope='north america', # Enfocar en América del Norte
            showland=True,
            landcolor="lightgray",
            showocean=True,
            oceancolor="lightblue",
            showcountries=True, # Mostrar líneas de países
            countrycolor="black",
            center=dict(lat=23.634501, lon=-102.552784), # Coordenadas aproximadas del centro de México
            projection_scale=4 # Ajusta este valor para hacer zoom en México
        ),
        height=700, # Ajustar altura según sea necesario
        showlegend=False
    )


    # --- Mostrar visualizaciones en Streamlit ---
    st.write("Attempting to display charts...") # Debug print before displaying charts


    # Puedes usar st.columns para organizar el layout si lo deseas
    # col1, col2 = st.columns(2)
    # with col1:
    #     st.plotly_chart(fig_gauge, use_container_width=True)
    # with col2:
    #     st.plotly_chart(fig_map, use_container_width=True)

    # O simplemente mostrarlos sequentially
    st.plotly_chart(fig_bar, use_container_width=True)
    st.plotly_chart(fig_gauge, use_container_width=True)
    st.plotly_chart(fig_map, use_container_width=True)
    st.write("Charts displayed.") # Debug print after displaying charts


except FileNotFoundError:
    st.error("Error: Asegúrate de que los archivos 'Base Notificaciones_Banco_Dummie.xlsx' y 'Latitud y longitud.xlsx' estén en la misma carpeta que el script de Streamlit.")
    st.stop() # Detiene la ejecución si los archivos no se encuentran
except Exception as e:
    st.error(f"An unexpected error occurred: {e}")

# Después de cargar df_notificaciones y df_coordenadas
st.write("DataFrame Notificaciones cargado:", df_notificaciones.head())
st.write("DataFrame Coordenadas cargado:", df_coordenadas.head())

# Después de la fusión
st.write("DataFrame fusionado (df_merged):", df_merged.head())
st.write("Shape de df_merged:", df_merged.shape)

# Después de calcular zona_counts
st.write("Conteo por Zona (zona_counts):", zona_counts.head())

# Después de calcular sí_percentage
st.write("Porcentaje de Confirmación 'Sí':", sí_percentage)

# Después de calcular plaza_geo_df y eliminar nulos
st.write("DataFrame Geográfico (plaza_geo_df):", plaza_geo_df.head())
st.write("Shape de plaza_geo_df:", plaza_geo_df.shape)